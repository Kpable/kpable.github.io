<!DOCTYPE html>
<html lang="en">

    <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=2020aeeb79f82d158dc144418d1d1aa15ae4dabe">
    <link rel="stylesheet" type="text/css" href="/assets/css/print.css" media="print">
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Corner Rotation | Kpable</title>
<meta property="og:title" content="Corner Rotation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Design Challenge Upon player reaching a corner of the tower, gameplay focus shifts to that side of the tower. Development Considerations With the designed player control for this 2.5D platformer being left, right, and jump, I considered how to both maintain that control constant and maintain view of the play space as the playing field shifted planes in 3D space." />
<meta property="og:description" content="Design Challenge Upon player reaching a corner of the tower, gameplay focus shifts to that side of the tower. Development Considerations With the designed player control for this 2.5D platformer being left, right, and jump, I considered how to both maintain that control constant and maintain view of the play space as the playing field shifted planes in 3D space." />
<link rel="canonical" href="http://localhost:4000/artificial-infiltration/corner-rotation" />
<meta property="og:url" content="http://localhost:4000/artificial-infiltration/corner-rotation" />
<meta property="og:site_name" content="Kpable" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-03-30T00:00:00-04:00" />
<script type="application/ld+json">
{"name":null,"description":"Design Challenge Upon player reaching a corner of the tower, gameplay focus shifts to that side of the tower. Development Considerations With the designed player control for this 2.5D platformer being left, right, and jump, I considered how to both maintain that control constant and maintain view of the play space as the playing field shifted planes in 3D space.","author":null,"@type":"BlogPosting","url":"http://localhost:4000/artificial-infiltration/corner-rotation","publisher":null,"image":null,"headline":"Corner Rotation","dateModified":"2017-03-30T00:00:00-04:00","datePublished":"2017-03-30T00:00:00-04:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/artificial-infiltration/corner-rotation"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header style="padding-bottom: 0px">
  <h1>Kpable</h1>
  <h2>Portfolio of a Gameplay Programmer</h2>
  <!-- <h3>Corner Rotation</h3> -->
</header>

<nav class="navbar navbar-expand-md">
  <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarsExample10" aria-controls="navbarsExample10" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="navbar-collapse justify-content-md-center collapse" id="navbarsExample10" style="">
    <ul class="navbar-nav">
      <div class="nav-item active">
        <a class="nav-link" href="http://localhost:4000">Home <span class="sr-only">(current)</span></a>
      </div>
      <div class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" id="dropdown10" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Projects</a>
        <div class="dropdown-menu" aria-labelledby="dropdown10">
          
            
              <a class="dropdown-item" href="/artificial-infiltration/">Artificial Infiltration (Assertive Games)</a>
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
        </div>
      </div>
    </ul>
  </div>
</nav> 

        <hr>

        <section id="main_content">
          <article>

<h1 class="post-title" itemprop="name headline">Corner Rotation</h1>

  <div class="post-content" itemprop="articleBody">
    <h4 id="design-challenge">Design Challenge</h4>
<p>Upon player reaching a corner of the tower, gameplay focus shifts to that side of the tower.</p>

<h4 id="development-considerations">Development Considerations</h4>
<p>With the designed player control for this 2.5D platformer being left, right, and jump, I considered how to both maintain that control constant and maintain view of the play space as the playing field shifted planes in 3D space.</p>

<p><img src="http://localhost:4000/assets/corner.gif" alt="Corner Rotation" /></p>

<!--excerpt_end-->

<h4 id="then-and-now-thoughts">Then and Now Thoughts</h4>

<p>“So, to get this going I just need to make sure</p>
<ul>
  <li>the player rotates about self to maintain left/right platformer control,</li>
  <li>the camera rotates about tower at a set distance to maintain view of the play space, and</li>
  <li>the player triggers both rotations once a corner is reached.</li>
</ul>

<p>Doesn’t sound too hard, shouldn’t be too bad.” 
<strong><em>- Past Me</em></strong></p>

<p>“No, Past Me, just no. You’ve got the right idea, but don’t ever assume that. You have no idea what designs may change or how other features will interact with this one. Don’t worry though, you’ll find out the <em>fun</em> way.” 
<strong><em>- Present Me</em></strong></p>

<h4 id="tldr">TL;DR</h4>
<ul>
  <li>Set up triggers at each corner to identify <strong>which corner was triggered</strong>.</li>
  <li>Created a way to determine <strong>what edge the payer is on</strong>.</li>
  <li>Figured out <strong>which edge the player is going to</strong>.</li>
  <li>Created relationship between <strong>edge and player rotation</strong>.</li>
  <li>Lerped player rotation between <strong>start and end rotations</strong> using edge/rotation relationship.</li>
  <li>Identified necessary <strong>camera positioning for each edge</strong>.</li>
  <li>Created relationship between <strong>edge and angles in a circle</strong>.</li>
  <li>Lerped camera position along circular path between <strong>start and end angles</strong> using edge/angle relationship.</li>
</ul>

<hr />

<h4 id="corner-triggering">Corner Triggering</h4>

<p>I started to work through this in the order I expected the player to experience. So first step, detecting when the player has reached a corner.</p>

<p>I placed four trigger colliders, one at each corner to detect when the player enters a corner. Because the player will be traveling upwards and as the programmer on the team, not knowing how tall the level designer will make a level’s tower, I also attach a quick script to the corner trigger to always follow the players vertical position. Player goes up, so do the triggers.</p>

<p>Upon entering the trigger, both the player and camera will be alerted to begin rotating onto the new edge. This also tells the player and camera <strong>which corner was triggered</strong>.</p>

<p><a href="https://github.com/Kpable/Artificial-Infiltration/blob/master/Scripts/Movement/Object/Corner_Switch.cs">Corner_Switch.cs</a></p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">OnTriggerEnter</span><span class="p">(</span><span class="n">Collider</span> <span class="n">col</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">insideTrigger</span> <span class="p">&amp;&amp;</span> <span class="n">col</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="n">name</span> <span class="p">==</span> <span class="s">"Player"</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cameraObject</span>
            <span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">CameraEdgeMovement</span><span class="p">&gt;()</span>
            <span class="p">.</span><span class="nf">RotateAroundCorner</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
        <span class="n">player</span>
            <span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">PlayerEdgeMovement</span><span class="p">&gt;()</span>
            <span class="p">.</span><span class="nf">RotateAroundCorner</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Later in development, a design change from a ‘one tower, constant size, at world origin’ plan to a ‘multiple towers, varying size, various locations’ plan, led me to create a helper script to automatically create and place the four corner triggers based on the square’s size.</p>

<p><a href="https://github.com/Kpable/Artificial-Infiltration/blob/master/Scripts/Movement/Object/Corners.cs">Corners.cs</a></p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="c1">// Sets a corner at the 4 corners
</span>
<span class="k">void</span> <span class="nf">PositionCornerTriggers</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">editInGame</span><span class="p">)</span> <span class="n">size</span> <span class="p">=</span> <span class="n">customSize</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">size</span> <span class="p">=</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">cubeSize</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>

    <span class="p">...</span>

    <span class="n">Vector3</span> <span class="n">pos</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">size</span> <span class="p">+</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> 
                                <span class="n">size</span> <span class="p">+</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
    <span class="n">corners</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">corners</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Corner_Switch</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">SetCorner</span><span class="p">(</span><span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">TopRightCorner</span><span class="p">);</span>

    <span class="n">pos</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(-</span><span class="n">size</span> <span class="p">+</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> 
                        <span class="n">size</span> <span class="p">+</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
    <span class="n">corners</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">corners</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Corner_Switch</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">SetCorner</span><span class="p">(</span><span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">TopLeftCorner</span><span class="p">);</span>

    <span class="n">pos</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">size</span> <span class="p">+</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> 
                        <span class="p">-</span><span class="n">size</span> <span class="p">+</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
    <span class="n">corners</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">corners</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Corner_Switch</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">SetCorner</span><span class="p">(</span><span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">BottomRightCorner</span><span class="p">);</span>

    <span class="n">pos</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(-</span><span class="n">size</span> <span class="p">+</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> 
                        <span class="p">-</span><span class="n">size</span> <span class="p">+</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
    <span class="n">corners</span><span class="p">[</span><span class="m">3</span><span class="p">].</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">corners</span><span class="p">[</span><span class="m">3</span><span class="p">].</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Corner_Switch</span><span class="p">&gt;()</span>
        <span class="p">.</span><span class="nf">SetCorner</span><span class="p">(</span><span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">BottomLeftCorner</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>I tried to make it as easy as possible for my other team members to be able create a new tower and have it function appropriately. For this script to work, the game object containing this script just had to placed close enough to the tower and it would be able to position each trigger appropriately based on the nearest tower’s position and size where size is the length or width of the square. But I digress.</p>

<h4 id="corner-rotations">Corner Rotations</h4>

<p>Next up was getting the player and the camera to rotate around a corner. For this I took pen to paper to figure out the kind of rotations both objects need to make and the similarities between them.</p>

<p>For each of the four corners on the square there’s both the clockwise and counter-clockwise rotation.</p>

<p><img src="http://localhost:4000/assets/corner-rotations.png" alt="The Eight Rotations" /></p>

<p>To determine which direction to rotate the playing field I needed to determine which edge the player is on.</p>

<h4 id="edge-tracking">Edge Tracking</h4>

<p>To identify which edge of the square the player is on I looked at the tower from above and designated the four edges.</p>

<p><img src="http://localhost:4000/assets/above_axis.png" alt="The Square From Above" /></p>

<p><a href="https://github.com/Kpable/Artificial-Infiltration/blob/master/Scripts/Utils.cs">Utils.cs</a></p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">enum</span> <span class="n">EdgeOfCube</span> 
<span class="p">{</span> 
    <span class="n">Bottom</span><span class="p">,</span> 
    <span class="n">Right</span><span class="p">,</span> 
    <span class="n">Top</span><span class="p">,</span> 
    <span class="n">Left</span><span class="p">,</span> 
    <span class="n">BottomRightCorner</span><span class="p">,</span> 
    <span class="n">BottomLeftCorner</span><span class="p">,</span> 
    <span class="n">TopRightCorner</span><span class="p">,</span> 
    <span class="n">TopLeftCorner</span><span class="p">,</span> 
    <span class="n">Lost</span> 
<span class="p">}</span></code></pre></figure>

<p>With each edge identified, I proceeded to find a method to find the edge the player is on given</p>
<ul>
  <li>the player’s position in the world</li>
  <li>the position of all four edges of any given tower in the world</li>
</ul>

<p>I do this by first locating the nearest tower to the player, then finding the nearest edge of that tower to the player.</p>

<p><a href="https://github.com/Kpable/Artificial-Infiltration/blob/master/Scripts/Utils.cs">Utils.cs</a></p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="c1">// Returns the Cube info of the nearest Cube
</span>
<span class="k">public</span> <span class="k">static</span> <span class="n">CubeSpace</span> <span class="nf">DetectNearestCube</span><span class="p">(</span><span class="n">Transform</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">cubes</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">CubeSpace</span> <span class="n">currentCube</span> <span class="p">=</span> <span class="n">cubes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">CubeSpace</span><span class="p">&gt;();</span>

        <span class="n">currentDistance</span> <span class="p">=</span> 
            <span class="n">Vector3</span><span class="p">.</span><span class="nf">Distance</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">currentCube</span><span class="p">.</span><span class="n">origin</span><span class="p">);</span>

        <span class="c1">// If first entry or this entry is closer than the previous
</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">==</span> <span class="m">0</span> <span class="p">||</span> <span class="n">minDistance</span> <span class="p">&gt;</span> <span class="n">currentDistance</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">minDistance</span> <span class="p">=</span> <span class="n">currentDistance</span><span class="p">;</span>
            <span class="n">closestCube</span> <span class="p">=</span> <span class="n">currentCube</span><span class="p">;</span>
        <span class="p">}</span>
        
    <span class="p">}</span>

    <span class="p">...</span>

    <span class="k">return</span> <span class="n">closestCube</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">static</span> <span class="n">EdgeOfCube</span> <span class="nf">DetectEdge</span><span class="p">(</span><span class="n">Transform</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="p">...</span>
    
    <span class="c1">// Sides
</span>

    <span class="c1">// Bottom - fixed negative z pos, variable x pos
</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">==</span> <span class="p">-</span><span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">z</span> <span class="p">&amp;&amp;</span> 
            <span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">&gt;</span> <span class="p">-</span><span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> 
            <span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">edge</span> <span class="p">=</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Bottom</span><span class="p">;</span>
    <span class="c1">// Top -    fixed positive z pos, variable x pos
</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">==</span> <span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">z</span> <span class="p">&amp;&amp;</span> 
            <span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">&gt;</span> <span class="p">-</span><span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> 
            <span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">edge</span> <span class="p">=</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Top</span><span class="p">;</span>
    <span class="c1">// Left -   fixed negative x pos, variable z pos
</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">==</span> <span class="p">-</span><span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> 
            <span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">&gt;</span> <span class="p">-</span><span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">z</span> <span class="p">&amp;&amp;</span> 
            <span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">&lt;</span> <span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">edge</span> <span class="p">=</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Left</span><span class="p">;</span>
    <span class="c1">// Right -  fixed positive x pos, variable z pos
</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">==</span> <span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> 
            <span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">&gt;</span> <span class="p">-</span><span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">z</span> <span class="p">&amp;&amp;</span> 
            <span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">&lt;</span> <span class="n">edgeDistance</span> <span class="p">+</span> <span class="n">cubePos</span><span class="p">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">edge</span> <span class="p">=</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Right</span><span class="p">;</span>

    <span class="p">...</span>

    <span class="k">return</span> <span class="n">edge</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now we know <strong>which edge the player is on</strong> and <strong>which corner the player triggered</strong> which gives us <strong>which edge the player is going to</strong>. With that additional information, I went on to consider how to rotate the player.</p>

<h4 id="player-rotation">Player Rotation</h4>

<p>For each edge the player is on the left and right axis changes.</p>

<p><img src="http://localhost:4000/assets/four-axes.png" alt="Four Axes" /></p>

<p>Because of this, instead of having the player object move left and right with respect to world space, I instead set the input to move left and right with respect to the player. This lets me be sure that the player object will always move left when the player wants to left and same for moving right.</p>

<p>Left and right when relative to an object is dependent on the objects rotation. So, the player object has to be rotated at each corner. AS the player moves clockwise around the tower, the player should rotate clockwise around the tower as well and vise-versa.</p>

<p>Starting with the bottom edge where the player’s axis matches the world’s axis, I identified all the rotation values the player object should have on any given side and created a helper function to retrieve those values.</p>

<p><a href="https://github.com/Kpable/Artificial-Infiltration/blob/master/Scripts/Utils.cs">Utils.cs</a></p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="c1">// Returns the rotation along the y axis of object's self 
</span>
<span class="c1">// based on the edge
</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">float</span> <span class="nf">EdgeToRotation</span><span class="p">(</span><span class="k">this</span> <span class="n">EdgeOfCube</span> <span class="n">edge</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">rotation</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Bottom</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Right</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="p">=</span> <span class="m">270f</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Top</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="p">=</span> <span class="m">180</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Left</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="p">=</span> <span class="m">90</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

            <span class="p">...</span>

        <span class="k">default</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">rotation</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Knowing which edge the player is on and which edge the player is going to, this relationship gives us the start and end rotations. It would be simple to just say,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>player.rotation = endRotation;
</code></pre></div></div>

<p>But it’s not about me or about code simplicity, it’s about the player’s experience and we want to make the player feel like they are rotating around a corner. One way to do that is to let them see themselves rotating around a corner. I do this by lerping between the start and end rotation values across an assigned duration.</p>

<p><a href="https://github.com/Kpable/Artificial-Infiltration/blob/master/Scripts/Player/PlayerEdgeMovement.cs">PlayerEdgeMovement.cs</a></p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rotating</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Add time in seconds
</span>
        <span class="n">currentRotationTime</span> <span class="p">+=</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
        <span class="c1">// Dont go more than the set rotationTime
</span>
        <span class="n">currentRotationTime</span> <span class="p">=</span> 
            <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp</span><span class="p">(</span><span class="n">currentRotationTime</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">rotationTime</span><span class="p">);</span>
        <span class="c1">// Lerp position 0 to 1 for duration rotationTime. 
</span>
        <span class="kt">float</span> <span class="n">lerpPos</span> <span class="p">=</span> <span class="n">currentRotationTime</span> <span class="p">/</span> <span class="n">rotationTime</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lerpPos</span> <span class="p">&gt;=</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="n">rotating</span><span class="p">)</span>
        <span class="p">{</span>               
            <span class="c1">// Keep it at a max of 1 so we don’t accidently go over  
</span>
            <span class="c1">// our desired angle.
</span>
            <span class="n">lerpPos</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>                            
            <span class="c1">// Set the current edge to the destination since we've
</span>
            <span class="c1">// reached it
</span>
            <span class="n">currentEdge</span> <span class="p">=</span> <span class="n">destinationEdge</span><span class="p">;</span>          
            <span class="c1">// We're done rotating.
</span>
            <span class="n">rotating</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>                      

            <span class="p">...</span>
        <span class="p">}</span>

        <span class="c1">// Angle between currentAngle &amp; destinationAngle at lerpPos
</span>
        <span class="kt">float</span> <span class="n">angle</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">LerpAngle</span><span class="p">(</span>
            <span class="n">currentEdge</span><span class="p">.</span><span class="nf">EdgeToRotation</span><span class="p">(),</span> 
            <span class="n">destinationEdge</span><span class="p">.</span><span class="nf">EdgeToRotation</span><span class="p">(),</span> 
            <span class="n">lerpPos</span><span class="p">);</span>

        <span class="c1">// Grab and set the player's rotation.
</span>
        <span class="n">Vector3</span> <span class="n">rot</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">rotation</span><span class="p">.</span><span class="n">eulerAngles</span><span class="p">;</span>
        <span class="n">rot</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">angle</span><span class="p">;</span>
        <span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="n">rot</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>That’s how the player rotates around corners and how it looks good too. So why not do something similar for the camera.</p>

<h4 id="camera-rotation">Camera Rotation</h4>

<p>First step was to satisfy the design requirement of always having the full length of a tower side and the player visible to the camera. I found that is possible using Unity’s default camera settings and setting the camera back the same distance from the tower’s origin as the length of either of the square tower’s sides.</p>

<p><img src="http://localhost:4000/assets/camera-center-distance.png" alt="Camera Distance From Center" /></p>

<p>This is assuming a 16:9 aspect ratio, as other ratios cut off a bit of the sides of the desired view. I remedied that by adjusting the camera’s field of view depending on detected aspect ratio.</p>

<p>Knowing that <strong>how far the camera should be</strong> is equivalent to the size of the tower itself, I proceeded to mark the remaining three positions the camera will be through the game on the XZ plane. like the corner triggers, the camera will also follow the player’s vertical position throughout play.</p>

<p><img src="http://localhost:4000/assets/camera_waypoints.png" alt="Camera Waypoints" /></p>

<p>Knowing <strong>where the camera is</strong> on the XZ plane and <strong>where the camera needs to go</strong> for each edge, I immediately thought of performing the same lerping as with the player’s rotation, just on the camera’s X and Z positions. But quickly found that would not satisfy the design requirement as previously mentioned. During the camera’s movement along a linear path to the next position, you’d lose sight of the player and most of the current playing field, which would be the two edges involved in the rotation.</p>

<p><img src="http://localhost:4000/assets/camera-wrong-paths.png" alt="Problem with Linear Camera Movement" /></p>

<p>To fix that, I knew I had to keep the camera at the same distance away from the origin at all time during its movement. With constant distance from tower origin and four target locations to hit in mind, movement along a circle quickly came to mind.</p>

<p><img src="http://localhost:4000/assets/way-above-axis.png" alt="Camera Movement Axis" /></p>

<p>I created a relationship between the edge and the angle of a circle on the XZ plane in world space.</p>

<p><a href="https://github.com/Kpable/Artificial-Infiltration/blob/master/Scripts/Utils.cs">Utils.cs</a></p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="c1">// Returns the angle of edge on X-Z axis in world space
</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">float</span> <span class="nf">EdgeToAngle</span><span class="p">(</span><span class="k">this</span> <span class="n">EdgeOfCube</span> <span class="n">edge</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">angle</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Bottom</span><span class="p">:</span>
            <span class="n">angle</span> <span class="p">=</span> <span class="m">270f</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Right</span><span class="p">:</span>
            <span class="n">angle</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Top</span><span class="p">:</span>
            <span class="n">angle</span> <span class="p">=</span> <span class="m">90f</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">EdgeOfCube</span><span class="p">.</span><span class="n">Left</span><span class="p">:</span>
            <span class="n">angle</span> <span class="p">=</span> <span class="m">180f</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

            <span class="p">...</span>

        <span class="k">default</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">angle</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Finally, to make it look nice, I do the same lerping I did for the player but instead of lerping the camera’s rotation, I instead lerp the <strong>start and end angles</strong> using the edge to angle relationship and set the camera’s position by plugging in the current angle value into the parametric equation for movement along the circumference of a circle with radius equal to the size of the tower and tower origin.</p>

<p><a href="https://github.com/Kpable/Artificial-Infiltration/blob/master/Scripts/Camera/CameraEdgeMovement.cs">CameraEdgeMovement.cs</a></p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">movingAroundCube</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>

        <span class="c1">// Parametric Equation for rotating around a circle
</span>
        <span class="n">Vector3</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
        <span class="n">pos</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> 
            <span class="n">Mathf</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="n">angle</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">Deg2Rad</span><span class="p">)</span> <span class="p">*</span>
            <span class="n">radius</span><span class="p">;</span>
        <span class="n">pos</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="n">nearestCube</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">z</span> <span class="p">+</span> 
            <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">angle</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">Deg2Rad</span><span class="p">)</span> <span class="p">*</span> 
            <span class="n">radius</span><span class="p">;</span>
        <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">pos</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>With that, we have the core of this feature. There were a lot of other considerations that were discovered during further development and testing. The following are some of the additional changes that were made because of their (<em>fun discoveries</em>):</p>

<ul>
  <li>Disabling player control during rotation. (<em>The player could move left/right mid rotation moving towards an infinite fall</em>)</li>
  <li>Preventing triggering while rotating. (<em>The shape and size of the corner and player colliders would occasionally cause a collision while rotating creating an infinite cycle of rotation</em>)</li>
  <li>Clamping the player’s position on an edge. (<em>The player would be offset the edge’s center line, didn’t look or feel good</em>)</li>
  <li>Maintain momentum after rotating. (<em>Entering mid jump would stop the jump after rotating and just drop the player to the floor</em>)</li>
  <li>Forcibly pushing the player out of a corner trigger on completion of trigger (<em>Even with disabling player control and adjusting comer and player colliders, the infinite cycle of rotation would still occasionally occur</em>)</li>
</ul>

<p>By <em>fun discoveries</em> I mean bugs. In case that wasn’t apparent. These are just a few off the top of my head too. Let’s just say it was a memorable feature.</p>


  </div>

</article>
        </section>

        <footer>
  This page was generated by <a href="https://pages.github.com">GitHub Pages</a> and is maintained by <a href="http://github.com/Kpable">Kpable</a>.
</footer>

<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" integrity="sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ" crossorigin="anonymous"></script>


      </div>
    </div>

    
  </body>

</html>
